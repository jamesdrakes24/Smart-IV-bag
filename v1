// Mega2560 + ST7796S TFT + XPT2046 Touch + BTS7960 (IBT-2)
// Touch buttons latch motion; physical pushbuttons stop motion when pressed.
// No extra status text. ROTATION = 3.
//
// --- TFT (ST7796S SPI) ---
// VCC->5V, GND->GND, LED->3.3V
// SDI(MOSI)->D51, SCK->D52, CS->D22, DC->D24, RST->RESET, SDO(MISO)->NC
//
// --- TOUCH (XPT2046 SPI) ---
// T_DIN->D51, T_CLK->D52, T_DO->D50, T_CS->D28, T_IRQ->NC
//
// --- BTS7960 (IBT-2) ---
// D5->RPWM (raise), D6->LPWM (lower), D7->R_EN, D8->L_EN
// Mega 5V->VCC (driver), GNDs common; 12V on B+/-; motor on M+/M-
//
// --- STOP PUSHBUTTONS (NO -> GND) ---
// RAISE stop: one wire->GND, other->D30  (press = LOW)
// LOWER stop: one wire->GND, other->D31  (press = LOW)
//
// --- Optional VIN sense ---
// VIN -> 10k -> A0 -> 10k -> GND   (A0 â‰ˆ VIN/2)

#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7796S.h>
#include <XPT2046_Touchscreen.h>
#include <string.h>

// ---------- Types ----------
struct UiButton { int16_t x,y,w,h; const char* label; bool lit; };

// ---------- Display / Touch ----------
#define ROTATION 3
#define TFT_CS   22
#define TFT_DC   24
#define TFT_RST  -1
#define TOUCH_CS 28
Adafruit_ST7796S tft(TFT_CS, TFT_DC, TFT_RST);
XPT2046_Touchscreen ts(TOUCH_CS);
int16_t W=480, H=320;

// ---- Touch calibration (yours) ----
const bool  useRawXforX = true;
const bool  useRawXforY = false;
const float ax = 0.129797f, bx = -32.12f;
const float ay = 0.086224f, by =  -5.68f;

// ---- Touch sampling ----
const uint8_t  N  = 3;
const uint16_t US = 200;

// ---------- Voltage sensing (optional) ----------
#define VOLT_PIN A0
const float VREF = 5.0f;
float readVIN(){ const uint8_t S=8; long s=0; for(uint8_t i=0;i<S;i++) s+=analogRead(VOLT_PIN);
  float adc=(float)s/S; float vA0=(adc*VREF)/1023.0f; return vA0*2.0f; }
long readVcc_mV(){ ADCSRB&=~_BV(MUX5); ADMUX=_BV(REFS0)|_BV(MUX3)|_BV(MUX2)|_BV(MUX1);
  delay(2); ADCSRA|=_BV(ADSC); while(ADCSRA&_BV(ADSC)){} uint16_t a=ADC; if(!a) return 0; return 1125300L/a; }

// ---------- BTS7960 pins ----------
const uint8_t PIN_RPWM=5, PIN_LPWM=6, PIN_REN=7, PIN_LEN=8;
uint8_t MOTOR_PWM = 200; // 0..255 speed cap

// ---------- Stop buttons (NO, pressed = LOW) ----------
const uint8_t PIN_STOP_UP  = 30;   // stops RAISE when pressed
const uint8_t PIN_STOP_DOWN= 31;   // stops LOWER when pressed

// ---------- UI ----------
UiButton bLower, bRaise;

// ---------- State machine ----------
enum MoveState { IDLE, MOVING_UP, MOVING_DOWN };
MoveState state = IDLE;

// ---------- Helpers ----------
static inline int16_t clamp16(int32_t v,int16_t lo,int16_t hi){ if(v<lo)return lo; if(v>hi)return hi; return (int16_t)v; }

void drawButton(const UiButton& b, bool on){
  uint16_t fill = on ? 0x07E0 : 0xFFFF;   // green when active
  tft.fillRoundRect(b.x,b.y,b.w,b.h,14, fill);
  tft.drawRoundRect(b.x,b.y,b.w,b.h,14, 0x0000);
  tft.setTextColor(0x0000); tft.setTextSize(2);
  int16_t tx=b.x+(b.w-(int)strlen(b.label)*12)/2, ty=b.y+(b.h-16)/2;
  tft.setCursor(tx,ty); tft.print(b.label);
}
bool hit(const UiButton& b,int16_t x,int16_t y){
  const int16_t pad=12; return x>=b.x-pad && x<b.x+b.w+pad && y>=b.y-pad && y<b.y+b.h+pad;
}
TS_Point medianRaw(){
  int16_t xs[5],ys[5];
  for(uint8_t i=0;i<N;i++){ TS_Point p=ts.getPoint(); xs[i]=p.x; ys[i]=p.y; delayMicroseconds(US); }
  auto sort=[&](int16_t*a){ for(uint8_t i=0;i<N;i++) for(uint8_t j=i+1;j<N;j++) if(a[j]<a[i]){int16_t t=a[i];a[i]=a[j];a[j]=t;} };
  sort(xs); sort(ys); return TS_Point(xs[N/2],ys[N/2],0);
}
bool readTouch(int16_t &px,int16_t &py){
  if(!ts.touched()) return false;
  TS_Point r=medianRaw();
  int32_t rx = useRawXforX ? r.x : r.y;
  int32_t ry = useRawXforY ? r.x : r.y;
  float xf=ax*rx+bx, yf=ay*ry+by;
  px=clamp16((int32_t)(xf+0.5f),0,W-1); py=clamp16((int32_t)(yf+0.5f),0,H-1);
  return true;
}

// ---------- Motor control (EN both HIGH on IBT-2) ----------
void motorSetup(){
  pinMode(PIN_RPWM,OUTPUT); pinMode(PIN_LPWM,OUTPUT);
  pinMode(PIN_REN,OUTPUT);  pinMode(PIN_LEN,OUTPUT);
  digitalWrite(PIN_REN,HIGH); digitalWrite(PIN_LEN,HIGH); // enable both sides
  analogWrite(PIN_RPWM,0);   analogWrite(PIN_LPWM,0);
}
inline void motorStop(){ analogWrite(PIN_RPWM,0); analogWrite(PIN_LPWM,0); }
inline void motorUp(){   analogWrite(PIN_LPWM,0); analogWrite(PIN_RPWM,MOTOR_PWM); }
inline void motorDown(){ analogWrite(PIN_RPWM,0); analogWrite(PIN_LPWM,MOTOR_PWM); }

// ---------- UI ----------
void drawStaticUI(){
  tft.fillScreen(0x0000);
  tft.setTextColor(0xFFFF); tft.setTextSize(2);
  tft.setCursor(10,10); tft.print("V:");
  const char* nctxt="KG: N/C"; int16_t tw=strlen(nctxt)*12;
  tft.setCursor(W-10-tw,10); tft.print(nctxt);
  const int16_t BW=200,BH=110,GAP=30;
  int16_t y=(H-BH)/2, x1=(W/2)-GAP/2-BW, x2=(W/2)+GAP/2;
  bLower={x1,y,BW,BH,"LOWER",false};
  bRaise={x2,y,BW,BH,"RAISE",false};
  drawButton(bLower,false); drawButton(bRaise,false);

  // ensure bottom area is blank
  tft.fillRect(0, H-40, W, 40, 0x0000);
}

// ---------- Arduino ----------
void setup(){
  tft.init(320,480); tft.setRotation(ROTATION); W=tft.width(); H=tft.height();
  ts.begin();
  analogReference(DEFAULT);

  // Stop buttons as NO with pullups (unpressed HIGH, pressed LOW)
  pinMode(PIN_STOP_UP,   INPUT_PULLUP);
  pinMode(PIN_STOP_DOWN, INPUT_PULLUP);

  drawStaticUI();
  motorSetup();
}

void loop(){
  // Voltage (VIN if present, else 5V)
  static uint32_t tPrev=0;
  if(millis()-tPrev>=100){
    tPrev=millis();
    float vin=readVIN(); bool haveVIN=(vin>1.0f);
    float vShow = haveVIN ? vin : (readVcc_mV()/1000.0f);
    const char* tag = haveVIN ? "VIN" : "5V";
    tft.fillRect(30,8,220,20,0x0000);
    tft.setCursor(30,10); tft.setTextSize(2); tft.setTextColor(0xFFFF);
    tft.print(vShow,2); tft.print("V "); tft.print(tag);
  }

  // Read stop buttons (NO): pressed = LOW
  bool stopUpPressed = (digitalRead(PIN_STOP_UP)   == LOW);
  bool stopDnPressed = (digitalRead(PIN_STOP_DOWN) == LOW);

  // Safety: if moving and its stop is pressed -> stop & unlatch the button
  if(state==MOVING_UP && stopUpPressed){
    state = IDLE; motorStop(); if(bRaise.lit){ bRaise.lit=false; drawButton(bRaise,false); }
  }
  if(state==MOVING_DOWN && stopDnPressed){
    state = IDLE; motorStop(); if(bLower.lit){ bLower.lit=false; drawButton(bLower,false); }
  }

  // Touch: latch motion on tap (ignore if that direction's stop is currently held)
  int16_t x,y;
  if(readTouch(x,y)){
    bool onLower = hit(bLower,x,y);
    bool onRaise = hit(bRaise,x,y);

    if(onRaise && !bRaise.lit && !stopUpPressed){
      state = MOVING_UP;
      bRaise.lit = true;  drawButton(bRaise,true);
      bLower.lit = false; drawButton(bLower,false);
    }
    if(onLower && !bLower.lit && !stopDnPressed){
      state = MOVING_DOWN;
      bLower.lit = true;  drawButton(bLower,true);
      bRaise.lit = false; drawButton(bRaise,false);
    }
  }

  // Drive motor per current state (latched)
  switch(state){
    case IDLE:        motorStop(); break;
    case MOVING_UP:   if(!stopUpPressed) motorUp();   else { state=IDLE; motorStop(); bRaise.lit=false; drawButton(bRaise,false); } break;
    case MOVING_DOWN: if(!stopDnPressed) motorDown(); else { state=IDLE; motorStop(); bLower.lit=false; drawButton(bLower,false); } break;
  }
}
